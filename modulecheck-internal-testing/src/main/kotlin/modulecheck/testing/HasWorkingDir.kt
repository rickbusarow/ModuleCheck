/*
 * Copyright (C) 2021-2023 Rick Busarow
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package modulecheck.testing

import modulecheck.utils.div
import modulecheck.utils.requireNotNull
import modulecheck.utils.segments
import java.io.File
import java.lang.StackWalker.StackFrame
import kotlin.streams.toList

/**
 * @param workingDir the directory containing all source and generated files to be used in this test
 */
@Suppress("UnnecessaryAbstractClass")
abstract class HasWorkingDir(workingDir: File) {

  /** the directory containing all source and generated files to be used in this test */
  val workingDir: File by lazy {
    checkInWorkingDir(workingDir)
    workingDir.deleteRecursively()
    workingDir
  }

  /** relative to [workingDir] */
  fun File.relativePath(): String = relativeTo(workingDir).path

  override fun toString(): String {
    return "workingDir=$workingDir\n" + getSourceReport()
  }

  protected fun getSourceReport(): String {

    val grouped = workingDir
      .walkBottomUp()
      .filter { it.isFile }
      .groupBy { generated ->
        val pathSegments = generated.relativeTo(workingDir).segments()

        if (pathSegments.size > 1) {
          pathSegments.first()
        } else {
          "<root>"
        }
      }
      .toList()
      .sortedBy { it.first }

    return buildString {
      appendLine("====")
      grouped.forEach { (type, files) ->
        appendLine("## $type")
        files.forEach { path ->
          appendLine("file://$path")
        }
      }
      appendLine("----")
    }
  }

  companion object {

    private val allWorkingDirs = mutableSetOf<File>()

    @PublishedApi
    internal fun checkInWorkingDir(workingDir: File) {
      synchronized(allWorkingDirs) {
        require(allWorkingDirs.add(workingDir)) {
          val annotation = "${SkipInStackTrace::class.simpleName}"
          """
          A working directory with this path has already been registered during this test run,
          meaning it would have multiple tests modifying it concurrently.

          This probably means you need to annotate a test factory function with `@$annotation`, like:

            @$annotation
            fun myTestFactory(
              @Language("proto")
              vararg content: String,
              /* ... /*
            ) = ...

          This is the working directory which would be duplicated: $workingDir
          """.trimIndent()
        }
      }
    }

    /**
     * Determines an appropriate working directory based upon the current class under
     * test, the languages being generated by Wire, and the current test function.
     *
     * @param testStackFrame the StackFrame which captures the actual test function, so
     *   that we can get the test name. This must be grabbed as soon as possible, since
     *   default functions, inline functions, sequences, and iterators all redirect
     *   things and have a chance of hiding the original calling function completely.
     * @param testVariantNames additional subdirectories underneath the test
     *   function's name, such as the names of the languages being generated
     * @return a File directory corresponding to the root of the working directory for this test
     */
    @SkipInStackTrace
    fun createWorkingDir(testStackFrame: StackFrame, testVariantNames: List<String>): File {

      val clazz = testStackFrame.declaringClass()

      // trim off all the stuff like "$$inlined$$execute$1""
      val actualClass = clazz.firstNonSyntheticClass()

      val declaringPackage = actualClass.packageName

      // nested classes and functions have the java `$` delimiter
      // ex: "com.example.MyTest$nested class$my test"
      fun String.segments(): List<String> = split(".", "$")
        .filter { it.isNotBlank() }

      val packageLength = declaringPackage.count { it == '.' }

      val classSimpleNames = actualClass.canonicalName.segments().drop(packageLength)

      val testFunctionName = testStackFrame.callingFunctionName().cleanForDir()

      val testClassName = classSimpleNames
        // "MyTest/nested class"
        .joinToString(File.separator)
        // "MyTest/nested_class"
        .replace("[^a-zA-Z\\d/]".toRegex(), "_")

      val classDir = File("build") / "tests" / testClassName

      val working = classDir / testFunctionName / testVariantNames
        .joinToString(File.separator)
        .replace("[^a-zA-Z\\d/]".toRegex(), "_")

      return working.absoluteFile
    }

    /**
     * Finds the stack trace element corresponding to the invoking test function.
     *
     * @return The StackFrame corresponding to the test function.
     */
    fun StackFrame.callingFunctionName(): String {
      val clazz = declaringClass()

      // trim off all the stuff like "$$inlined$$execute$1""
      val actualClass = clazz.firstNonSyntheticClass()

      // nested classes and functions have the java `$` delimiter
      // ex: "com.example.MyTest$nested class$my test"
      fun String.segments(): List<String> = split(".", "$")
        .filter { it.isNotBlank() }

      return clazz.name.removePrefix(actualClass.name)
        .segments()
        .firstOrNull()
        ?: methodName
    }

    @PublishedApi
    internal fun String.cleanForDir(): String = replace("[^a-zA-Z\\d]".toRegex(), "_")
      .replace("_{2,}".toRegex(), "_")
      .removeSuffix("_")

    /**
     * Finds the stack trace element corresponding to the invoking test
     * function. This should be called as close as possible to the test function.
     */
    @SkipInStackTrace
    fun testStackFrame(): StackFrame = StackWalker
      .getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)
      .walk { frames ->

        val allGoodFrames = frames
          // skip the first since it's this function and not the calling test
          .skip(1)
          .filter { !it.isSkipped() }
          .toList()

        val callingFunctionName = allGoodFrames
          .firstOrNull()
          .requireNotNull { "Could not find a stack frame which is not skipped." }
          .callingFunctionName()

        allGoodFrames.last { it.methodName == callingFunctionName }
      }
  }
}
