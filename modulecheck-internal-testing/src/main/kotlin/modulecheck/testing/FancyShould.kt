/*
 * Copyright (C) 2021-2023 Rick Busarow
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package modulecheck.testing

import kotlinx.coroutines.runBlocking
import modulecheck.utils.flatMapToSet
import modulecheck.utils.requireNotNull
import org.jetbrains.kotlin.util.prefixIfNot
import java.io.File
import kotlin.reflect.KClass
import io.kotest.matchers.shouldBe as kotestShouldBe

interface FancyShould {

  infix fun File.shouldHaveText(expected: String) {

    readText() shouldBe expected
  }

  infix fun String.shouldBe(expected: String) {

    val actualClean = prefixIfNot("\n").trimIndent()
    val expectedClean = expected.trimIndent()

    actualClean.trimmedShouldBe(expectedClean)
  }

  infix fun <T, U : T> T.shouldBe(expected: U?) {
    trimmedShouldBe(expected)
  }
}

fun <T, U : T> T.trimmedShouldBe(expected: U?, vararg excludeFromStack: KClass<*>) {
  trimmedAssert(*excludeFromStack) {
    kotestShouldBe(expected)
  }
}

/**
 * returns the output of [assertion], or cleans up the stacktrace of any assertion errors before
 * rethrowing
 *
 * @since 0.12.4
 */
fun <R> trimmedAssert(
  vararg excludeFromStack: KClass<*>,
  assertion: suspend () -> R
): R = Unit.trimmedAssert(*excludeFromStack) { assertion() }

/**
 * returns the output of [assertion], or cleans up the stacktrace of any assertion errors before
 * rethrowing
 *
 * @since 0.12.4
 */
fun <T, R> T.trimmedAssert(
  vararg excludeFromStack: KClass<*>,
  assertion: suspend T.() -> R
): R {

  /*
  Any AssertionError generated by this function will have this function at the top of its stacktrace.

  The actual call site for the assertion is always the _second_ line.

  So, we can catch the assertion error, remove this function from the stacktrace, and rethrow.
   */
  return try {
    runBlocking { assertion() }
  } catch (assertionError: AssertionError) {

    val excludes = sequenceOf(FancyShould::class, BaseTest::class)
      .plus(excludeFromStack)
      .map { it.qualifiedName.requireNotNull() }
      .flatMapToSet { fqName -> setOf(fqName, "${fqName}Kt") }
      .flatMapToSet { fqName ->
        setOf(
          fqName,
          "${fqName}\$DefaultImpls",
          "${fqName}\$runBlocking\$1",
          "${fqName}\$shouldBe\$1",
          "${fqName}\$trimmedAssert\$1",
          "${fqName}\$trimmedShouldBe\$1"
        )
      }
      .plus(
        setOf(
          "io.kotest.common.runBlocking",
          "kotlin.coroutines.jvm.internal.BaseContinuationImpl",
          "kotlinx.coroutines.AbstractCoroutine",
          "kotlinx.coroutines.BlockingCoroutine",
          "kotlinx.coroutines.BuildersKt",
          "kotlinx.coroutines.BuildersKt__BuildersKt",
          "kotlinx.coroutines.DispatchedTask",
          "kotlinx.coroutines.EventLoopImplBase",
          "kotlinx.coroutines.internal.ScopeCoroutine"
        )
      )

    // remove this function from the stacktrace and rethrow
    @Suppress("MagicNumber")
    assertionError.stackTrace = assertionError
      .stackTrace
      .dropWhile { it.className in excludes || it.methodName == "shouldBe" }
      .take(15) // keep stack traces short
      .toTypedArray()
    throw assertionError
  }
}
