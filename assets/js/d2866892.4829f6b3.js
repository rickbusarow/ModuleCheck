"use strict";(self.webpackChunkmodulecheck=self.webpackChunkmodulecheck||[]).push([[1900],{5168:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"rules/compiler/unused_kapt_processor","title":"Unused Kapt Processor","description":"Annotation processors act upon a defined set of annotations. If an annotation processor is","source":"@site/versioned_docs/version-0.12.1/rules/compiler/unused_kapt_processor.md","sourceDirName":"rules/compiler","slug":"/rules/unused_kapt_processor","permalink":"/ModuleCheck/docs/0.12.1/rules/unused_kapt_processor","draft":false,"unlisted":false,"editUrl":"https://github.com/rbusarow/ModuleCheck/blob/main/website/versioned_docs/version-0.12.1/rules/compiler/unused_kapt_processor.md","tags":[],"version":"0.12.1","frontMatter":{"id":"unused_kapt_processor","slug":"/rules/unused_kapt_processor","title":"Unused Kapt Processor","sidebar_label":"Unused Kapt Processor"},"sidebar":"Docs","previous":{"title":"Could Use Anvil Factory Generation","permalink":"/ModuleCheck/docs/0.12.1/rules/use_anvil_factory_generation"},"next":{"title":"Unused Kapt Plugin","permalink":"/ModuleCheck/docs/0.12.1/rules/unused_kapt_plugin"}}');var t=s(23420),r=s(65404);const i={id:"unused_kapt_processor",slug:"/rules/unused_kapt_processor",title:"Unused Kapt Processor",sidebar_label:"Unused Kapt Processor"},a=void 0,c={},d=[];function l(e){const n={code:"code",em:"em",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Annotation processors act upon a defined set of annotations. If an annotation processor is\nsufficiently popular and its api is stable, then it's relatively simple to define a list of\nannotations to search for. For instance, Dagger looks for the following annotations:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"javax.inject.Inject"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"dagger.Binds"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"dagger.Module"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"dagger.multibindings.IntoMap"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"dagger.multibindings.IntoSet"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"dagger.BindsInstance"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"dagger.Component"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"dagger.assisted.Assisted"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"dagger.assisted.AssistedInject"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"dagger.assisted.AssistedFactory"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"com.squareup.anvil.annotations.ContributesTo"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"com.squareup.anvil.annotations.MergeComponent"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"com.squareup.anvil.annotations.MergeSubomponent"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If a module has the Dagger ",(0,t.jsx)(n.code,{children:"kapt"})," dependency, and that module ",(0,t.jsx)(n.em,{children:"does not"})," have one of the above\nannotations somewhere, then Dagger isn't actually doing anything and can be removed."]}),"\n",(0,t.jsx)(n.p,{children:"This is simply a best-effort approach, and it isn't maintenance-free. Over time, the list of\nannotations for any processor may change. If this rule gives a false-positive finding because of a\nnew annotation, please open an issue and/or pull request."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},65404:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>a});var o=s(36672);const t={},r=o.createContext(t);function i(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);